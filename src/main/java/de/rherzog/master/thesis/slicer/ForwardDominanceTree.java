package de.rherzog.master.thesis.slicer;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.jgrapht.Graph;
import org.jgrapht.GraphPath;
import org.jgrapht.alg.shortestpath.AllDirectedPaths;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.io.ComponentNameProvider;
import org.jgrapht.io.ExportException;

import com.ibm.wala.shrikeBT.IInstruction;
import com.ibm.wala.shrikeCT.InvalidClassFileException;

public class ForwardDominanceTree extends SlicerGraph<Integer> {
	private ControlFlow controlFlow;
	private Graph<Integer, DefaultEdge> graph;

	public ForwardDominanceTree(ControlFlow controlFlowGraph) {
		this.controlFlow = controlFlowGraph;
	}

	@Override
	public Graph<Integer, DefaultEdge> getGraph() throws IOException, InvalidClassFileException {
		if (graph != null) {
			return graph;
		}
		IInstruction[] instructions = controlFlow.getMethodData().getInstructions();
		graph = new DefaultDirectedGraph<>(DefaultEdge.class);

		// Every vertex in the control flow is present in the forward dominance graph
		// as well.
		Graph<Integer, DefaultEdge> cfg = controlFlow.getGraph();
		cfg.vertexSet().forEach(v -> graph.addVertex(v));

		Map<Integer, Set<Integer>> dom = new HashMap<>();

		// https://en.wikipedia.org/wiki/Dominator_(graph_theory)
		final int n0 = 0;
//		 // dominator of the start node is the start itself
//		 Dom(n0) = {n0}
		dom.put(n0, new HashSet<>(Set.of(0)));

//		 // for all other nodes, set all nodes as the dominators
//		 for each n in N - {n0}
//		     Dom(n) = N;
		final Set<Integer> N = IntStream.range(0, instructions.length).boxed().collect(Collectors.toSet());
//		 for each n in N - {n0}
		for (int n : N) {
			if (n == n0) {
				continue;
			}
//		     Dom(n) = N;
			dom.put(n, N);
		}

//		 // iteratively eliminate nodes that are not dominators
//		 while changes in any Dom(n)
//		     for each n in N - {n0}:
//		         Dom(n) = {n} union with intersection over Dom(p) for all p in pred(n)

		AllDirectedPaths<Integer, DefaultEdge> cfgPaths = new AllDirectedPaths<>(cfg);

		// while changes in any Dom(n)
		boolean changes = false;
		do {
			changes = false;

			// for each n in N - {n0}:
			for (int n : N) {
				if (n == n0) {
					continue;
				}
				// Dom(n) = {n} union with intersection over Dom(p) for all p in pred(n)
				final Set<Integer> dom_n = new HashSet<>(Set.of(n));
				final Set<Integer> intersection = new HashSet<>(N);

				// for all p in pred(n)
				for (DefaultEdge edge : controlFlow.getGraph().incomingEdgesOf(n)) {
					final int p = controlFlow.getGraph().getEdgeSource(edge);

					final Set<Integer> dom_p = dom.get(p);
					intersection.retainAll(dom_p);

//					// TODO This is somehow inefficient here. There are all paths generated by
//					// JGrapthT and compared. At least nested paths can be omitted since they are
//					// included in the longer ones. Even the target vertices are not selected
//					// optimal. It might be possible to figure out if the target vertex set can be
//					// reduced. For example it is impossible to reach a previous instruction if
//					// there is no conditional branch or loop to go back on the CFG.
//					final List<GraphPath<Integer, DefaultEdge>> allPathsFromPrevN = cfgPaths.getAllPaths(Set.of(prevN),
//							N, true, null);
//					for (GraphPath<Integer, DefaultEdge> graphPath : allPathsFromPrevN) {
//						if (graphPath.getLength() == 0) {
//							// Self-path is not interesting right now
//							continue;
//						}
//
//						// Get all dominators for all vertices on the path and intersect them
//						for (int p : graphPath.getVertexList()) {
//							final Set<Integer> dom_p = dom.get(p);
//							intersection.retainAll(dom_p);
//						}
//					}

				}

				// Dom(n) = {n} union with intersection
				dom_n.addAll(intersection);
				final Set<Integer> oldDom_n = dom.get(n);
				if (!oldDom_n.equals(dom_n)) {
					changes |= true;
					dom.put(n, dom_n);
				}
			}
		} while (changes);

		for (Entry<Integer, Set<Integer>> entry : dom.entrySet()) {
			System.out.println(entry);
		}

//		// TODO First dominator
//		Map<Integer, Integer> firstImmediateDominators = new HashMap<>();
//
//		for (int vertex : dom.keySet()) {
//			int firstImmediateDominator = -1;
//			for (Set<Integer> dominations : dom.values()) {
//				if (!dominations.contains(vertex)) {
//					continue;
//				}
//				List<Integer> dominationList = new ArrayList<>(dominations);
//				Collections.sort(dominationList);
//
//				final int indexOfVertex = dominationList.indexOf(vertex);
//				if (dominationList.size() == indexOfVertex + 2) {
//					firstImmediateDominator = Math.max(firstImmediateDominator,
//							dominationList.get(indexOfVertex + 1));
//				}
//			}
//			firstImmediateDominators.put(vertex, firstImmediateDominator);
//		}

//		Map<Integer, Integer> ifdom = new HashMap<>();
//		// Add domination indexes to the final graph
		for (Entry<Integer, Set<Integer>> entry : dom.entrySet()) {
			if (entry.getKey() == 0) {
				continue;
			}
//
//			int immediateForwardDominator = 0;
//			for (int domIndex : entry.getValue()) {
//				if (domIndex == entry.getKey()) {
//					continue;
//				}
//				immediateForwardDominator = Math.max(immediateForwardDominator, domIndex);
//
//				// Only add an edge to the graph if there is a precedence in the cfg. Instead it
//				// would yield to an absolute chaotic graph faaar away from being a tree.
////				if (controlFlow.getGraph().containsEdge(domIndex, entry.getKey())) {
////					graph.addEdge(entry.getKey(), domIndex); // Forward
////					graph.addEdge(domIndex, entry.getKey()); // Reverse
////				}
//			}
////			graph.addEdge(entry.getKey(), immediateForwardDominator); // Reverse
//////			graph.addEdge(immediateForwardDominator, entry.getKey()); // Forward
		}
		return graph;
	}

	public Integer getImmediateForwardDominator(int index) throws IOException, InvalidClassFileException {
		final Set<DefaultEdge> incomingEdges = getGraph().incomingEdgesOf(index);
		if (incomingEdges.size() == 1) {
			// Usual case
			return getGraph().getEdgeSource(incomingEdges.iterator().next());
		}
		if (incomingEdges.size() == 0) {
			// Unusual case
			return null;
		}
		// Error
		throw new IllegalStateException("There are " + incomingEdges.size()
				+ " immediate forward dominators for index " + index + " which is not possible");
	}

	@Override
	protected String dotPrint() throws IOException, InvalidClassFileException, ExportException {
		IInstruction[] instructions = controlFlow.getMethodData().getInstructions();

		// use helper classes to define how vertices should be rendered,
		// adhering to the DOT language restrictions
		ComponentNameProvider<Integer> vertexIdProvider = new ComponentNameProvider<Integer>() {
			public String getName(Integer index) {
				return String.valueOf(index);
			}
		};
		ComponentNameProvider<Integer> vertexLabelProvider = new ComponentNameProvider<Integer>() {
			public String getName(Integer index) {
				return index + ": " + instructions[index].toString();
			}
		};
		return getExporterGraphString(vertexIdProvider, vertexLabelProvider);
	}

}
